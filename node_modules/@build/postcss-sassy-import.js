/**
 * PostCSS Sassy Import
 * Implements imports like Sass, plus:
 * - Import only one time by default
 * - Import Sass, CSS, JSON, and JS files
 *
 * Used instead of postcss-import because of philosophical differences.
 */

"use strict";

// Our plugin!
let plugin;

const postcss = require("postcss");
const path = require("path");
const glob = require("glob");
const fs = require("fs");

// We sort of need this?
let syntaxSCSS;
try {
	syntaxSCSS = require("postcss-scss");
} catch(e) {
	throw new Error("postcss-scss needs to be installed!");
}

// File formats we accept
const formats = [
	"%", // full file path
	"%.scss", // SCSS
	"_%.scss", // SCSS partial
	"%.css", // CSS
	"%.json", // JSON data (Sass variables)
	"%.js" // JS data (Sass variables from export)
];

// Loaders based on file
// For these loaders, the only plugin PostCSS needs is this import plugin.
// All other plugins will run over the source afterwards.
const loaders = [
	[/\.scss$/, (wrapped, opts) => {
		opts = opts || {};

		return postcss([ plugin(opts) ])
			.process(wrapped.contents, {
				from: wrapped.path,
				syntax: syntaxSCSS
			});
	}],
	[/\.css$/, (wrapped, opts) => {
		opts = opts || {};

		return postcss([ plugin(opts) ])
			.process(wrapped.contents, {
				from: wrapped.path
			});
	}]
];

/**
 * Takes an unresolved path and returns a list of possible locations
 */
function resolvePath(unresolved) {
	const parsed = path.parse(unresolved);

	return formats.map(format => {
		return path.join(parsed.dir, format.replace("%", parsed.base));
	});
}

/**
 * Reads a file as UTF-8 text using a Promise
 */
function readFile(file) {
	return new Promise((resolve, reject) => {
		fs.readFile(file, (err, contents) => {
			if (err) {
				return reject(err);
			}

			resolve(contents.toString("utf-8"));
		});
	});
}

/**
 * Wraps a path and contents into a single object
 */
function wrapFile(filePath, contents) {
	return {
		path: filePath,
		contents: contents
	};
}

/**
 * Loads all of the given files in order, then returns an array of wrapped files.
 */
function getFilesAllOf(paths) {
	let proms = [];

	for (const filePath of paths) {
		let prom = readFile(filePath)
			.then(contents => wrapFile(filePath, contents));

		proms.push(prom);
	}

	return Promise.all(proms);
}

/**
 * Loads the given files in order, returning a wrapped file on success
 */
function getFileOneOf(paths) {
	let prom = Promise.reject();

	for (const file of paths) {
		let wrapContents = (contents) => wrapFile(file, contents);

		// Read files until one succeeds
		prom = prom
			.catch(() => readFile(file).then(wrapContents))
			.then(result => {
				return result;
			});
	}

	return prom
		.catch(() => {
			return new Error("Couldn't find any of the given files: " + paths.join(", "));
		});
}

/**
 * Takes a resolved file path and returns the correct loader for it, if one is found.
 */
function getLoader(filePath) {
	for (const loader of loaders) {
		if (loader[0].test(filePath)) {
			return loader[1];
		}
	}
}

/**
 * A promiseified version of glob
 */
function globPromise(dir) {
	return new Promise((resolve, reject) => {
		glob(dir, (err, matches) => {
			if (err) {
				return reject(err);
			}

			resolve(matches);
		});
	});
}

plugin = postcss.plugin("postcss-sassy-import", opts => {
	opts = opts || {};

	// Files that have already been loaded
	const loaded = opts.loaded || new Set();
	opts.loaded = loaded;

	return (css, result) => {
		// Returns Promise<PostCSSNode>
		const processNormal = (unresolved) => {
			return Promise.resolve()
				.then(() => {
					const possible = resolvePath(unresolved);

					console.log("normal, first of", possible.join(", "));

					return getFileOneOf(possible);
				})
				.then((file) => {
					if (loaded.has(file.path)) {
						// TODO: signal that this has already been loaded?
						console.warn("Skipping ", file.path, "-- was already loaded.");
						return;
					}

					loaded.add(file.path);

					const loader = getLoader(file.path);

					return loader(file, opts)
						.then(r => r.root);
				});
		};

		// Returns Promise<PostCSSNode[]>
		const processGlob = (unresolved) => {
			return Promise.resolve()
				.then(() => globPromise(unresolved))
				.then(matches => {
					matches = matches.filter(file => !loaded.has(file));

					console.log("glob, all of", matches.join(", "));

					return getFilesAllOf(matches);
				}).then(matches => {
					let prom = Promise.resolve([]);

					for (const match of matches) {
						const loader = getLoader(match.path);

						if (!loader) {
							console.warn("Couldn't find loader for ", match.path, " -- skipping...");
							continue;
						}

						prom = prom.then((result) => {
							return loader(match, opts)
								.then(res => {
									result.push(res);

									return result;
								});
						});
					}

					return prom
						.then(results => results.map(r => r.root));
				});
		};

		// Our workhorse!
		return new Promise((resolve, reject) => {
			let prom = Promise.resolve();

			css.walkAtRules("import", (node) => {
				// Strip off quotes, single and double
				const fragment = node.params
					.replace(/^['"]/, "")
					.replace(/['"]$/, "");

				const origin = node.source.input.file;

				const unresolved = path.normalize(path.join(path.dirname(origin), fragment));

				console.log("import", fragment);

				if (glob.hasMagic(fragment)) {
					prom = prom.then(() => {
						console.log("We've loaded ", Array.from(loaded).join(", "));

						return processGlob(unresolved);
					}).then(newNodes => {
						if (newNodes.length > 0) {
							node.replaceWith(...newNodes);
						} else {
							node.remove();
						}
					});
				} else {
					prom = prom.then(() => {
						console.log("We've loaded ", Array.from(loaded).join(", "));

						return processNormal(unresolved);
					}).then(newNode => {
						if (newNode) {
							node.replaceWith(newNode);
						} else {
							node.remove();
						}
					});
				}
			});

			resolve(prom);
		});
	};
});

module.exports = plugin;