/**
 * PostCSS Sassy Import
 * Implements imports like Sass, plus:
 * - Import only one time by default
 * - Import Sass, CSS, JSON, and JS files
 *
 * Used instead of postcss-import because of philosophical differences.
 */

// TODO: move formats + loaders into opts parameter
// TODO: document
// TODO: move to separate plugin

"use strict";

// Our plugin!
let plugin;

const path = require("path");
const fs = require("fs");
const vm = require("vm");

const postcss = require("postcss");
const glob = require("glob");

// We sort of need this?
let syntaxSCSS;
try {
	syntaxSCSS = require("postcss-scss");
} catch(e) {
	throw new Error("postcss-scss needs to be installed!");
}

/**
 * Takes an unresolved path and returns a list of possible locations
 */
function resolvePath(formats, unresolved) {
	const parsed = path.parse(unresolved);

	return formats.map(format => {
		return path.join(parsed.dir, format.replace("%", parsed.base));
	});
}

/**
 * Reads a file as UTF-8 text using a Promise
 */
function readFile(file) {
	return new Promise((resolve, reject) => {
		fs.readFile(file, (err, contents) => {
			if (err) {
				return reject(err);
			}

			resolve(contents.toString("utf-8"));
		});
	});
}

/**
 * Wraps a path and contents into a single object
 */
function wrapFile(filePath, contents) {
	return {
		path: filePath,
		contents: contents
	};
}

/**
 * Loads all of the given files in order, then returns an array of wrapped files.
 */
function getFilesAllOf(paths) {
	let proms = [];

	for (const filePath of paths) {
		let prom = readFile(filePath)
			.then(contents => wrapFile(filePath, contents));

		proms.push(prom);
	}

	return Promise.all(proms);
}

/**
 * Loads the given files in order, returning a wrapped file on success
 */
function getFileOneOf(paths) {
	let prom = Promise.reject();

	for (const file of paths) {
		let wrapContents = (contents) => wrapFile(file, contents);

		// Read files until one succeeds
		prom = prom
			.catch(() => readFile(file).then(wrapContents))
			.then(result => {
				return result;
			});
	}

	return prom
		.catch(() => {
			return new Error("Couldn't find any of the given files: " + paths.join(", "));
		});
}

/**
 * Takes a resolved file path and returns the correct loader for it, if one is found.
 */
function getLoader(loaders, filePath) {
	for (const loader of loaders) {
		if (loader[0].test(filePath)) {
			return loader[1];
		}
	}
}

/**
 * A promiseified version of glob
 */
function globPromise(dir) {
	return new Promise((resolve, reject) => {
		glob(dir, (err, matches) => {
			if (err) {
				return reject(err);
			}

			resolve(matches);
		});
	});
}

function arrayToSCSS(object) {
	return `(${ object.map(v => toSCSS(v)).join(", ") })`;
}

function objectToSCSS(object) {
	let keys = Object.keys(object);
	let building = [];
	keys.forEach(key => {
		let val = toSCSS(object[key]);

		if (val !== undefined) {
			building.push(`${ key }: ${ val }`);
		}
	});

	return `(${ building.join(", ") })`;
}

function toSCSS(object) {
	if (typeof object === "string") {
		return `"${ object.replace(`"`, `\"`) }"`;
	} else if (typeof object === "number") {
		return object.toString();
	} else if (typeof object === "object") {
		if (Array.isArray(object)) {
			return arrayToSCSS(object);
		} else {
			return objectToSCSS(object);
		}
	} else if (typeof object === "boolean") {
		return object.toString();
	}

	return undefined;
}

function rootToSCSS(object) {
	let keys = Object.keys(object);
	let building = [];

	keys.forEach(key => {
		let val = toSCSS(object[key]);

		if (val !== undefined) {
			building.push(`$${ key }: ${ val };`);
		}
	});

	return building.join("\n");
}

function createSandbox() {
	let sandbox = {
		module: {}
	};

	return sandbox;
}

plugin = postcss.plugin("postcss-sassy-import", function(opts) {
	opts = Object.assign({}, opts) || {};

	// Files that have already been loaded
	const loaded = opts.loaded || new Set();
	opts.loaded = loaded;

	// File formats we accept
	const formats = opts.formats || [
		"%", // full file path
		"%.scss", // SCSS
		"_%.scss", // SCSS partial
		"%.css", // CSS
		"%.json", // JSON data (Sass variables)
		"%.js" // JS data (Sass variables from export)
	];

	opts.formats = formats;

	// Loaders based on file
	// For these loaders, the only plugin PostCSS needs is this import plugin.
	// All other plugins will run over the source afterwards.
	const loaders = opts.loaders || [
		[/\.scss$/, (wrapped, opts) => {
			opts = opts || {};

			return postcss([ plugin(opts) ])
				.process(wrapped.contents, {
					from: wrapped.path,
					syntax: syntaxSCSS
				});
		}],
		[/\.css$/, (wrapped, opts) => {
			opts = opts || {};

			return postcss([ plugin(opts) ])
				.process(wrapped.contents, {
					from: wrapped.path
				});
		}],
		[/\.json$/, (wrapped, opts) => {
			const data = JSON.parse(wrapped.contents);

			const scss = rootToSCSS(data);

			return postcss([ plugin(opts) ])
				.process(scss, {
					from: wrapped.path,
					syntax: syntaxSCSS
				});
		}],
		[/\.js$/, (wrapped, opts) => {
			const sandbox = createSandbox();

			const script = new vm.Script(wrapped.contents);
			script.runInNewContext(sandbox);

			const res = sandbox.module.exports;

			if (res) {
				const scss = rootToSCSS(res);

				return postcss([ plugin(opts) ])
					.process(scss, {
						from: wrapped.path,
						syntax: syntaxSCSS
					});
			}
		}]
	];

	opts.loaders = loaders;

	return (css, result) => {
		// Returns Promise<PostCSSNode>
		const processNormal = (unresolved) => {
			return Promise.resolve()
				.then(() => {
					const possible = resolvePath(formats, unresolved);

					return getFileOneOf(possible);
				})
				.then((file) => {
					if (loaded.has(file.path)) {
						// TODO: signal that this has already been loaded?
						console.warn("Skipping ", file.path, "-- was already loaded.");
						return;
					}

					loaded.add(file.path);

					const loader = getLoader(loaders, file.path);

					return loader(file, opts)
						.then(r => r.root);
				});
		};

		// Returns Promise<PostCSSNode[]>
		const processGlob = (unresolved) => {
			return Promise.resolve()
				.then(() => globPromise(unresolved))
				.then(matches => {
					// Early-out for globbed files
					matches = matches.filter(file => !loaded.has(file));

					return getFilesAllOf(matches);
				}).then(matches => {
					// Progressively build up a PostCSSNode[]
					let prom = Promise.resolve([]);

					for (const match of matches) {
						const loader = getLoader(loaders, match.path);

						// TODO: add config option for this
						if (!loader) {
							console.warn("Couldn't find loader for ", match.path, " -- skipping...");
							continue;
						}

						prom = prom.then((result) => {
							// This file could've been loaded as a dep earlier in the glob
							if (loaded.has(match.path)) {
								return result;
							}

							loaded.add(match.path);

							return loader(match, opts)
								.then(res => {
									result.push(res);

									return result;
								});
						});
					}

					return prom
						.then(results => results.map(r => r.root));
				});
		};

		// Our workhorse!
		return new Promise((resolve, reject) => {
			let prom = Promise.resolve();

			css.walkAtRules("import", (node) => {
				// Strip off quotes, single and double
				const fragment = node.params
					.replace(/^['"]/, "")
					.replace(/['"]$/, "");

				const origin = node.source.input.file;

				const unresolved = path.normalize(path.join(path.dirname(origin), fragment));

				if (glob.hasMagic(fragment)) {
					prom = prom.then(() => {
						return processGlob(unresolved);
					}).then(newNodes => {
						if (newNodes.length > 0) {
							node.replaceWith(...newNodes);
						} else {
							node.remove();
						}
					});
				} else {
					prom = prom.then(() => {
						return processNormal(unresolved);
					}).then(newNode => {
						if (newNode) {
							node.replaceWith(newNode);
						} else {
							node.remove();
						}
					});
				}
			});

			resolve(prom);
		});
	};
});

module.exports = plugin;