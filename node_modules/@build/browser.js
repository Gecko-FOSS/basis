"use strict";

let core = require("./core");
let load = core.load;

let path = load("path");
let fs = load("fs");
let gulp = load("gulp");

let merge = load("merge-stream");
let source = load("vinyl-source-stream");
let buffer = load("vinyl-buffer");

let browserify = load("browserify");
let tsify = load("tsify");
let watchify = load("watchify");

let gutil = load("gulp-util");
let notify = load("gulp-notify");
let gulpif = load("gulp-if");
let sourcemaps = load("gulp-sourcemaps");
let rename = load("gulp-rename");
let insert = load("gulp-insert");
let uglify = load("gulp-uglify");

core.buildTasks.push("build:browser");

gulp.task("build:browser", () => {
	let merged = merge();

	let buildPath = core.out;

	for (let transform of core.getTransforms("browser")) {
		let dest = path.join(buildPath, transform.dest);
		let ppath = path.parse(dest);
		let outDir = ppath.dir;
		let outFile = ppath.base;

		let entries = [transform.source];

		if (transform.extraEntries) {
			entries.push(...transform.extraEntries);
		}

		let args = watchify.args;
		args.extensions = [".ts"];
		args.entries = entries;
		args.debug = true;

		let bundler = browserify(args);

		if (core.watch) {
			bundler = watchify(bundler);
		}

		bundler = bundler.plugin(tsify, transform.config);

		let rebundle = () => {
			gutil.log(gutil.colors.green(core.getName(transform) + ": building..."));

			let stream = bundler.bundle()
				.on("error", core.onError)
				.pipe(source(transform.source))
				.pipe(buffer());

			if (core.sourcemaps) {
				stream = stream
					.pipe(sourcemaps.init({loadMaps: true}))
			}

			if (core.minify) {
				stream = stream
					.pipe(uglify())
			}

			stream = stream
				.pipe(rename(ppath.base))
				.pipe(insert.prepend(`"use strict"; `));

			if (core.sourcemaps) {
				stream = stream
					.pipe(sourcemaps.write("./"));
			}

			stream = stream
				.pipe(gulp.dest(outDir))
				.pipe(core.browserSync.stream());

			if (core.notify) {
				stream = stream.pipe(notify({
					message: core.getName(transform) + ": done!",
					onLast: true
				}));
			}
		}

		if (core.watch) {
			bundler.on("update", rebundle);
		}

		rebundle();
	}

	return merged;
});