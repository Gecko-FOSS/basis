"use strict";

let core = require("./core");
let load = core.load;

let path = load("path");
let fs = load("fs");
let gulp = load("gulp");

let merge = load("merge-stream");

let sass = load("gulp-ruby-sass");
let rename = load("gulp-rename");
let autoprefixer = load("gulp-autoprefixer");
let minifyCSS = load("gulp-minify-css");
let sourcemaps = load("gulp-sourcemaps");
let notify = load("gulp-notify");
let gutil = load("gulp-util");

core.buildTasks.push("build:styles");

let buildTransform = (transform) => {
	gutil.log(gutil.colors.green(core.getName(transform) + ": building..."));

	let buildPath = core.getBuildPath();

	let dest = path.join(buildPath, transform.dest);
	let ppath = path.parse(dest);

	let stream = sass(transform.source, transform.config)
		.on("error", core.onError)
		.pipe(rename(ppath.base))
		.pipe(autoprefixer("last 2 versions"));

	if (core.minify) {
		stream = stream
			.pipe(minifyCSS({
				processImport: false
			}));
	}

	if (core.sourcemaps) {
		stream = stream
			.pipe(sourcemaps.write("./"));
	}

	stream = stream
		.pipe(gulp.dest(ppath.dir))
		.pipe(core.browserSync.stream())
		.pipe(notify({
			message: core.getName(transform) + ": done!"
		}));

	return stream;
};

gulp.task("build:styles", () => {
	let merged = merge();

	for (let transform of core.getTransforms("styles")) {
		merged.add(buildTransform(transform));

		let sourcedir = path.parse(transform.source).dir;

		if (!core.once) {
			gulp.watch(sourcedir + "/**/*.*", e => {
				buildTransform(transform);
			});
		}
	}

	return merged;
});