"use strict";

const core = require("./core");
const load = core.load;

const path = load("path");
const gulp = load("gulp");

const merge = load("merge-stream");

const sass = load("gulp-sass");

const postcss = load("gulp-postcss");
const syntaxSCSS = load("postcss-scss");
const sassyImport = load("postcss-sassy-import");

const autoprefixer = load("autoprefixer");
const cssnano = load("cssnano");
const stylelint = load("stylelint");
const reporter = load("postcss-reporter");

const rename = load("gulp-rename");
const sourcemaps = load("gulp-sourcemaps");
const notify = load("gulp-notify");
const gutil = load("gulp-util");

core.buildTasks.push("build:styles");

const buildTransform = (transform) => {
	gutil.log(gutil.colors.green(core.getName(transform) + ": building..."));

	let buildPath = core.out;

	let dest = path.join(buildPath, transform.dest);
	let ppath = path.parse(dest);

	let sassConf = {};

	if (transform.config && transform.config.sass) {
		Object.assign(sassConf, transform.config.sass);
	}

	// Processors run before Sass
	let preProcessors = [];

	// Processors run after Sass
	let postProcessors = [];

	let sassyImportConfig = {};

	if (transform.config && transform.config.sassyImport) {
		Object.assign(sassyImportConfig, transform.config.sassyImport);
	}

	// This plugin drives our style imports
	preProcessors.push(sassyImport(sassyImportConfig));

	// The linter!
	if (transform.config && transform.config.stylelint) {
		preProcessors.push(stylelint(transform.config.stylelint));
	}

	// Autoprefixer for a great good!
	if (transform.config && transform.config.autoprefixer) {
		preProcessors.push(autoprefixer(transform.config.autoprefixer));
	}

	// CSS minifier
	// cssnano comes with autoprefixer, which we handle ourselves
	if (core.minify) {
		postProcessors.push(cssnano({ autoprefixer: false }));
	}

	// Plugin to report PostCSS warnings and errors, mostly from stylelint
	preProcessors.push(reporter({
		clearMessages: true,
		throwError: true
	}));

	const handler = core.getErrorHandler(core.getName(transform));

	let stream = gulp.src(transform.source)
		.pipe(sourcemaps.init())
		.pipe(postcss(preProcessors, { syntax: syntaxSCSS, sourcemap: true }))
			.on("error", () => null)
		.pipe(sass(sassConf).on("error", sass.logError))
		.pipe(postcss(postProcessors), { sourcemap: true })
		.pipe(rename(ppath.base));

	if (core.sourcemaps) {
		stream = stream
			.pipe(sourcemaps.write("./"));
	}

	stream = stream
		.pipe(gulp.dest(ppath.dir))
		.pipe(core.browserSync.stream())
		.pipe(core.getNotify(core.getName(transform) + ": done!"));

	return stream;
};

gulp.task("build:styles", () => {
	let merged = merge();

	for (let transform of core.getTransforms("styles")) {
		merged.add(buildTransform(transform));

		let sourcedir = path.parse(transform.source).dir;

		if (core.watch) {
			gulp.watch(sourcedir + "/**/*.scss", e => {
				return buildTransform(transform);
			});

			gulp.watch(sourcedir + "/**/*.json", e => {
				return buildTransform(transform);
			});
		}
	}

	return merged;
});