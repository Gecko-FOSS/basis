"use strict";

// load configuration
let conf;
try {
	conf = require("../../build.user.conf");
} catch(e) {
	conf = require("../../build.conf");
}

// pull the process arguments we care about out
let args = [];

for (let i = 2; i < process.argv.length; i++) {
	let arg = process.argv[i];

	if (arg.startsWith("--")) {
		args = process.argv.slice(i);
		break;
	}
}

// black list: don't build these modules
// white list: only build these modules
// gray list: build these modules despite defaults
let params = {
	white: null,
	gray: null,
	black: null
};

let getValue = (name, base, core) => {
	let conf = core.conf;

	if (params[name] != null) {
		return params[name];
	}

	if (core.preset[name] != null) {
		return core.preset[name];
	}

	if (conf[name] != null) {
		return conf[name];
	}

	return base;
};

let core = {
	version: "2.0.0",

	modules: ["browser", "server", "styles", "static"],
	buildTasks: [],
	browserSync: null,

	conf: conf,
	params: params,

	get: (key) => getValue(key, null, core),

	get preset() {
		let name = params.preset || conf.preset;

		if (!conf.presets[name]) {
			console.error(`Couldn't find preset '${name}'!`);
			process.exit(1);
			return;
		}

		return conf.presets[name];
	},

	get once() {
		return getValue("once", false, core);
	},

	get production() {
		return getValue("production", false, core);
	},

	get sourcemaps() {
		return getValue("sourcemaps", !core.production, core);
	},

	get minify() {
		return getValue("minify", !core.production, core);
	},

	get out() {
		return getValue("out", "derp", core);
	},

	load: (path) => {
		try {
			return require(path);
		} catch(e) {
			console.log(`Couldn't load module "${path}", try running "npm install"`);
			process.exit();
		}
	},

	getName: (transform) => {
		if (transform.name) {
			return transform.name;
		}

		return transform.type.charAt(0).toUpperCase() + transform.type.slice(1);
	},

	getTransforms: (type) => {
		let params = core.params;
		let transforms = [...core.conf.transforms];

		if (core.preset.transforms) {
			transforms.push(...core.preset.transforms);
		}

		return transforms.filter(transform => {
			let name = (transform.name || transform.type).toLowerCase();

			if (type != null && transform.type !== type) {
				return false;
			}

			if (params.black && params.black[name]) {
				return false;
			}

			if (params.white && !params.white[name]) {
				return false;
			}

			if (transform.disabled) {
				if (params.gray) {
					if (!params.gray[name]) {
						return false;
					}
				} else {
					return false;
				}
			}

			return true;
		});
	},

	onError: function(err) {
		require("gulp-notify").onError("Error: <%= error.message %>")(err);

		this.emit("end");
	}
};

{
	let modes = {
		white: true,
		gray: true,
		black: true
	};

	let flags = {
		once: true,
		production: true,
		sourcemaps: true,
		minify: true
	};

	let settings = {
		preset: true,
		out: true
	};

	let aliases = {
		"only": "white",
		"except": "black"
	};

	let toBoolean = (v) => {
		v = v.toLowerCase();

		if (v === "true" || v === "yes") {
			return true;
		}

		if (v === "false" || v === "no") {
			return false;
		}

		return true;
	};

	for (let arg of args) {
		if (!arg.startsWith("--")) {
			console.error(`Unknown command line option '${arg}'`);
			process.exit(1);
		}

		arg = arg.slice(2).toLowerCase();
		arg = aliases[arg] || arg;

		let setter = arg.match(/^([^=]+)=(.+)/);

		if (!setter) {
			if (flags[arg]) {
				params[arg] = true;
				continue;
			}

			console.error(`Unknown command line option '${arg}'`);
			process.exit(1);
		}

		let key = setter[1];
		let value = setter[2];

		key = aliases[key] || key;

		if (modes[key]) {
			if (params[key] == null) {
				params[key] = {};
			}

			let list = value.split(",");
			for (let e of list) {
				params[key][e.toLowerCase()] = true;
			}

			continue;
		}


		if (flags[key]) {
			params[key] = toBoolean(value);
			continue;
		}

		if (settings[key]) {
			params[key] = value;
			continue;
		}
	}
}

module.exports = core;