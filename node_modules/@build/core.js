"use strict";

// load configuration
let conf;
try {
	conf = require("../../build.user.conf");
} catch(e) {
	conf = require("../../build.conf");
}

// Load package (if present)
let pack;
try {
	pack = require("../../package.json");
} catch(e) {
	pack = {
		name: "UNKNOWN",
		version: "UNKNOWN"
	};
}

let version = "UNKNOWN";
if (pack.guh) {
	if (pack.guh.version) {
		version = pack.guh.version;
	}
} else if (pack.name === "guh") {
	version = pack.version;
}

const Loader = require("./dep-loader");

const load = (path) => {
	try {
		return require(path);
	} catch(e) {
		console.log(`Couldn't load module "${path}", try running "npm install"`);
		throw e;
		process.exit();
	}
};

const gutil = load("gulp-util");

const getValue = (name, base, core) => {
	if (core.params[name] != null) {
		return core.params[name];
	}

	if (core.preset[name] != null) {
		return core.preset[name];
	}

	if (core.conf[name] != null) {
		return core.conf[name];
	}

	return base;
};

const core = {
	name: pack.name,
	version: version,

	modules: ["pipelines/browser", "pipelines/server", "pipelines/styles", "pipelines/static"],
	buildTasks: [],
	browserSync: null,

	conf: conf,
	params: {},

	get: (key) => getValue(key, null, core),

	get preset() {
		let name = core.params.preset || core.conf.preset;

		if (!core.conf.presets[name]) {
			console.error(`Couldn't find preset '${name}'!`);
			process.exit(1);
			return;
		}

		return core.conf.presets[name];
	},

	get watch() {
		return getValue("watch", false, core);
	},

	get notify() {
		return getValue("notify", false, core);
	},

	get sourcemaps() {
		return getValue("sourcemaps", true, core);
	},

	get minify() {
		return getValue("minify", false, core);
	},

	get out() {
		return getValue("out", "out", core);
	},

	get useBrowsersync() {
		return getValue("browsersync", !!(core.preset.browserSync || core.conf.browserSync), core);
	},

	load: load,
	getLoader() {
		return new Loader();
	},

	getName(transform) {
		if (transform.name) {
			return transform.name;
		}

		return transform.type.charAt(0).toUpperCase() + transform.type.slice(1);
	},

	getPipelines(type) {
		let params = core.params;
		let unfiltered = [...core.conf.pipelines];

		if (core.preset.pipelines) {
			unfiltered.push(...core.preset.pipelines);
		}

		let byID = new Map();
		let unID = [];

		for (let transform of unfiltered) {
			if (transform.id != null) {
				let existing = byID.get(transform.id);

				if (existing) {
					Object.assign(existing, transform);
				} else {
					byID.set(transform.id, transform);
				}
			} else {
				unID.push(transform);
			}
		}

		let pipelines = unID.slice();

		for (let pair of byID) {
			let transform = pair[1];
			pipelines.push(transform);
		}

		return pipelines.filter(transform => {
			let name = (transform.id || transform.name || transform.type || "unnamed").toLowerCase();

			if (type != null && transform.type !== type) {
				return false;
			}

			if (params.black && params.black[name]) {
				return false;
			}

			if (params.white && !params.white[name]) {
				return false;
			}

			if (transform.disabled) {
				if (params.gray) {
					if (!params.gray[name]) {
						return false;
					}
				} else {
					return false;
				}
			}

			return true;
		});
	},

	verifyPipeline(pipeline) {
		if (typeof pipeline !== "object") {
			return new Error("Expected a pipeline object.");
		}

		if (typeof pipeline.source !== "string") {
			return new Error("Expected a string for the pipeline 'source' property.");
		}

		if (typeof pipeline.dest !== "string") {
			return new Error("Expected a string for the pipeline 'dest' property.");
		}

		if (pipeline.name != null && typeof pipeline.name !== "string") {
			return new Error("Expected null or a string for the pipeline 'name' property.");
		}

		if (pipeline.config != null && typeof pipeline.config !== "object") {
			return new Error("Expected null or an object for the pipeline 'config' property.");
		}

		return true;
	},

	error(err) {
		gutil.log(gutil.colors.red("Error: " + err.toString()));

		process.exit(1);
	},

	onError(err) {
		if (core.notify) {
			require("gulp-notify").onError("Error: <%= error.message %>")(err);
		} else {
			gutil.log(gutil.colors.red("Build error!"));
			gutil.log(err.message);
		}

		this.emit("end");
	},

	getErrorHandler: function(name) {
		return function(err) {
			if (core.notify) {
				require("gulp-notify").onError("Error: <%= error.message %>")(err);
			} else {
				gutil.log(gutil.colors.red(name + ": Build error!"));
				gutil.log(err.message);
				gutil.log(err.stack);
			}

			this.emit("end");
		};
	},

	getNotify(msg) {
		let notify = require("gulp-notify");

		let notifier;

		if (!core.notify) {
			notifier = (options, callback) => callback();
		}

		return notify({
			message: msg,
			onLast: true,
			notifier: notifier
		});
	}
};

module.exports = core;